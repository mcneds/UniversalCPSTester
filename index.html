<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Input CPS Tester</title>
  <style>
    :root{
      --bg:#0b0f17;
      --text:#e6edf7;
      --muted:#a6b3c7;
      --line:#23314a;
      --good:#4ade80;
      --warn:#fbbf24;
      --bad:#fb7185;
      --accent:#60a5fa;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 800px at 70% 0%, #111c33 0%, var(--bg) 60%);
      color:var(--text);
      min-height:100vh;
    }
    header{
      padding:20px 18px 8px;
      max-width:1100px;
      margin:0 auto;
      display:flex;
      gap:14px;
      align-items:flex-end;
      justify-content:space-between;
    }
    header h1{margin:0;font-size:20px;letter-spacing:.2px}
    header .sub{margin:0;color:var(--muted);font-size:12px;line-height:1.3}
    main{
      max-width:1100px;
      margin:0 auto;
      padding:12px 18px 30px;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
    }
    @media (max-width: 980px){ main{grid-template-columns:1fr} }

    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid var(--line);
      border-radius:14px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .row.spread{justify-content:space-between}
    .pill{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.02);
      font-size:12px;
      color:var(--muted);
      user-select:none;
    }
    .pill strong{color:var(--text); font-weight:650}

    .btn{
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-weight:650;
      cursor:pointer;
      transition:transform .04s ease, background .1s ease;
      user-select:none;
    }
    .btn:hover{background:rgba(255,255,255,.06)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{
      border-color: rgba(96,165,250,.5);
      background: rgba(96,165,250,.12);
    }
    .btn.danger{
      border-color: rgba(251,113,133,.45);
      background: rgba(251,113,133,.10);
    }
    .btn:disabled{cursor:not-allowed;opacity:.55}

    .seg{
      display:flex;
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
    }
    .seg button{
      border:0;
      background:transparent;
      color:var(--muted);
      padding:10px 12px;
      cursor:pointer;
      font-weight:650;
    }
    .seg button.active{
      background:rgba(255,255,255,.05);
      color:var(--text);
    }

    .grid2{display:grid;grid-template-columns: 1fr 1fr;gap:10px}
    .label{font-size:12px;color:var(--muted);margin-bottom:6px}
    select, input[type="number"]{
      width:100%;
      border:1px solid var(--line);
      background:rgba(255,255,255,.02);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      outline:none;
    }
    .check{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      color:var(--text);
      user-select:none;
    }
    .check input{transform: translateY(1px)}

    .stats{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
    }
    @media (max-width: 980px){ .stats{grid-template-columns: repeat(2,1fr)} }
    .stat{
      border:1px solid var(--line);
      background:rgba(255,255,255,.02);
      border-radius:14px;
      padding:12px;
      min-height:74px;
    }
    .stat .k{font-size:12px;color:var(--muted);margin-bottom:6px}
    .stat .v{font-size:22px;font-weight:750;letter-spacing:.2px}
    .stat .s{font-size:12px;color:var(--muted);margin-top:4px}

    canvas{
      width:100%;
      height:180px;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
    }

    .hint{font-size:12px;color:var(--muted);line-height:1.35}
    .divider{height:1px;background:var(--line);margin:12px 0}

    .statusDot{
      width:8px;height:8px;border-radius:50%;
      background:var(--bad);
      display:inline-block;margin-right:6px;
      box-shadow: 0 0 0 3px rgba(251,113,133,.12);
      vertical-align:middle;
    }
    .statusDot.good{
      background:var(--good);
      box-shadow: 0 0 0 3px rgba(74,222,128,.12);
    }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      padding:2px 6px;
      border:1px solid var(--line);
      border-bottom-color:#2f4365;
      border-radius:8px;
      background:rgba(255,255,255,.03);
      color:var(--text);
    }

    /* Test Pad */
    .testPad{
      margin-top:10px;
      border:1px dashed rgba(96,165,250,.45);
      background:rgba(96,165,250,.06);
      border-radius:14px;
      padding:16px;
      min-height:110px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      color:var(--muted);
      user-select:none;
      position:relative;
      overflow:hidden;
    }
    .testPad strong{color:var(--text)}
    .testPad:focus{
      outline:2px solid rgba(96,165,250,.35);
      outline-offset:2px;
    }
    .padSub{
      font-size:12px;
      margin-top:6px;
      color:var(--muted);
    }
    .padBadge{
      display:inline-block;
      margin-left:8px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(96,165,250,.35);
      background:rgba(96,165,250,.10);
      font-size:12px;
      color:var(--text);
      vertical-align:middle;
    }
    .cooldownBarWrap{
      position:absolute;
      left:10px;
      right:10px;
      bottom:10px;
      height:6px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
      overflow:hidden;
      display:none;
    }
    .cooldownBar{
      height:100%;
      width:0%;
      background:rgba(96,165,250,.65);
      border-radius:999px;
    }
  </style>
</head>

<body>
  <header>
    <div>
      <h1>Input CPS Tester</h1>
      <p class="sub">Click the Test Pad to start. Timed tests (1–60s) + Unlimited mode with peak/current/rolling stats.</p>
    </div>
    <div class="pill"><span class="statusDot" id="focusDot"></span><strong id="focusText">Not focused</strong></div>
  </header>

  <main>
    <!-- LEFT: Controls -->
    <section class="card">
      <div class="row spread">
        <div class="seg" role="tablist" aria-label="Mode">
          <button id="modeTimed" class="active" type="button">Timed</button>
          <button id="modeUnlimited" type="button">Unlimited</button>
        </div>
        <div class="pill"><strong id="runState">Idle</strong></div>
      </div>

      <div class="divider"></div>

      <div id="timedControls">
        <div class="label">Interval</div>
        <div class="grid2">
          <select id="durationSelect">
            <option value="1">1s</option>
            <option value="2">2s</option>
            <option value="3">3s</option>
            <option value="5">5s</option>
            <option value="10" selected>10s</option>
            <option value="15">15s</option>
            <option value="20">20s</option>
            <option value="30">30s</option>
            <option value="60">60s</option>
          </select>
          <div>
            <div class="label">Rolling avg window</div>
            <select id="rollingSelectTimed">
              <option value="5">5s</option>
              <option value="10" selected>10s</option>
              <option value="20">20s</option>
              <option value="60">60s</option>
            </select>
          </div>
        </div>
      </div>

      <div id="unlimitedControls" style="display:none">
        <div class="grid2">
          <div>
            <div class="label">Rolling avg window</div>
            <select id="rollingSelectUnlimited">
              <option value="5">5s</option>
              <option value="10" selected>10s</option>
              <option value="20">20s</option>
              <option value="60">60s</option>
            </select>
          </div>
          <div>
            <div class="label">History length</div>
            <select id="historySelect">
              <option value="30">30s</option>
              <option value="60" selected>60s</option>
              <option value="120">120s</option>
              <option value="300">300s</option>
            </select>
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="row">
        <button class="btn primary" id="btnStart" type="button">Start</button>
        <button class="btn danger" id="btnStop" type="button" disabled>Stop</button>
        <button class="btn" id="btnReset" type="button">Reset</button>
      </div>

      <div class="divider"></div>

      <div class="label">Count inputs from</div>
      <div class="grid2">
        <label class="check"><input type="checkbox" id="countKeyboard" checked> Keyboard (keydown)</label>
        <label class="check"><input type="checkbox" id="countMouse" checked> Mouse buttons</label>
        <label class="check"><input type="checkbox" id="countWheel"> Mouse wheel</label>
        <label class="check"><input type="checkbox" id="countTouch"> Touch / pen</label>
        <label class="check"><input type="checkbox" id="countGamepad" checked> Gamepad buttons</label>
      </div>

      <div class="divider"></div>

      <div class="grid2">
        <label class="check"><input type="checkbox" id="ignoreKeyRepeat" checked> Ignore key repeat</label>
        <label class="check"><input type="checkbox" id="preventScrollKeys" checked> Prevent scroll keys</label>
      </div>

      <div class="divider"></div>

      <div class="hint">
        <div><span class="kbd">Tip</span> Click the <strong>Test Pad</strong> to start. Right-click menu is disabled on the pad.</div>
        <div style="margin-top:6px">Timed mode has a short cooldown after finishing so it won’t instantly restart while you’re still clicking.</div>
      </div>

      <div class="divider"></div>

      <div class="label">Detected gamepads</div>
      <div class="pill" id="gpList" style="width:100%; text-align:left">None</div>
    </section>

    <!-- RIGHT: Stats + Graph + Test Pad -->
    <section class="card">
      <div class="stats">
        <div class="stat">
          <div class="k">Time</div>
          <div class="v" id="timeMain">0.00s</div>
          <div class="s" id="timeSub">—</div>
        </div>
        <div class="stat">
          <div class="k">Total Inputs</div>
          <div class="v" id="totalInputs">0</div>
          <div class="s" id="lastInput">Last: —</div>
        </div>
        <div class="stat">
          <div class="k">Average CPS</div>
          <div class="v" id="avgCps">0.00</div>
          <div class="s">Total / elapsed</div>
        </div>

        <div class="stat">
          <div class="k">Current CPS</div>
          <div class="v" id="curCps">0</div>
          <div class="s">Inputs in last 1s</div>
        </div>
        <div class="stat">
          <div class="k">Peak CPS</div>
          <div class="v" id="peakCps">0</div>
          <div class="s">Best 1s window</div>
        </div>
        <div class="stat">
          <div class="k">Rolling Avg CPS</div>
          <div class="v" id="rollCps">0.00</div>
          <div class="s" id="rollSub">Last 10s</div>
        </div>
      </div>

      <!-- TEST PAD -->
      <div id="testPad" class="testPad" tabindex="0" aria-label="Test pad">
        <div>
          <div style="font-size:13px; margin-bottom:6px;">
            <strong id="padTitle">Test Pad</strong>
            <span class="padBadge" id="padBadge">Click to start</span>
          </div>
          <div class="padSub" id="padSub">
            Left / middle / right click count • right-click menu disabled • keyboard works when page is focused
          </div>
        </div>
        <div class="cooldownBarWrap" id="cooldownBarWrap">
          <div class="cooldownBar" id="cooldownBar"></div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="row spread">
        <div class="pill"><strong>History graph</strong> (per-second CPS)</div>
        <div class="pill" id="modeHint">Timed mode</div>
      </div>
      <div style="margin-top:10px">
        <canvas id="chart" width="900" height="260"></canvas>
      </div>

      <div class="divider"></div>

      <div class="hint">
        Counts <strong>press events</strong>:
        keyboard = keydown, mouse = pointer button down, gamepad = button transitions (up→down).
        If you want “clicks only”, uncheck keyboard and gamepad.
      </div>
    </section>
  </main>

  <script>
    // ---------- Helpers ----------
    const $ = (id) => document.getElementById(id);

    function formatSeconds(sec){
      if (!isFinite(sec)) return "—";
      return sec.toFixed(sec < 10 ? 2 : 1) + "s";
    }

    function isUiControlTarget(target){
      if (!target || !(target instanceof Element)) return false;
      return !!target.closest("button, select, input, textarea, a, label, [role='button']");
    }

    // ---------- UI Elements ----------
    const modeTimedBtn = $("modeTimed");
    const modeUnlimitedBtn = $("modeUnlimited");
    const timedControls = $("timedControls");
    const unlimitedControls = $("unlimitedControls");
    const durationSelect = $("durationSelect");
    const rollingSelectTimed = $("rollingSelectTimed");
    const rollingSelectUnlimited = $("rollingSelectUnlimited");
    const historySelect = $("historySelect");

    const btnStart = $("btnStart");
    const btnStop = $("btnStop");
    const btnReset = $("btnReset");

    const countKeyboard = $("countKeyboard");
    const countMouse = $("countMouse");
    const countWheel = $("countWheel");
    const countTouch = $("countTouch");
    const countGamepad = $("countGamepad");
    const ignoreKeyRepeat = $("ignoreKeyRepeat");
    const preventScrollKeys = $("preventScrollKeys");

    const runStateEl = $("runState");
    const modeHint = $("modeHint");
    const timeMain = $("timeMain");
    const timeSub = $("timeSub");
    const totalInputsEl = $("totalInputs");
    const lastInputEl = $("lastInput");
    const avgCpsEl = $("avgCps");
    const curCpsEl = $("curCps");
    const peakCpsEl = $("peakCps");
    const rollCpsEl = $("rollCps");
    const rollSubEl = $("rollSub");
    const gpListEl = $("gpList");
    const testPad = $("testPad");
    const padBadge = $("padBadge");
    const padSub = $("padSub");
    const cooldownBarWrap = $("cooldownBarWrap");
    const cooldownBar = $("cooldownBar");

    const focusDot = $("focusDot");
    const focusText = $("focusText");

    const canvas = $("chart");
    const ctx = canvas.getContext("2d");

    // ---------- State ----------
    let mode = "timed";     // "timed" | "unlimited"
    let running = false;

    let startWall = 0;      // performance.now() at start
    let stopWall = 0;       // performance.now() at stop/finish (freezes time)
    let endWall = null;     // performance.now() at end for timed mode

    let durationSec = 10;
    let rollingWindowSec = 10;
    let historySec = 60;

    let totalInputs = 0;
    let lastInputLabel = "—";

    let last1sQueue = [];   // timestamps within last 1s
    let buckets = [];       // per-second counts since start
    let lastBucketIndex = -1;
    let peakCps = 0;

    // Timed-mode cooldown to prevent instant restart on spam clicks
    const COOLDOWN_MS = 500;          // change this if you want
    let cooldownUntil = 0;            // performance.now() timestamp
    let cooldownStartedAt = 0;        // for progress bar

    // Gamepad state
    let gpPrev = new Map(); // index -> pressed array

    // ---------- Mode switching ----------
    function setMode(next){
      mode = next;
      const isTimed = mode === "timed";
      modeTimedBtn.classList.toggle("active", isTimed);
      modeUnlimitedBtn.classList.toggle("active", !isTimed);
      timedControls.style.display = isTimed ? "" : "none";
      unlimitedControls.style.display = isTimed ? "none" : "";
      modeHint.textContent = isTimed ? "Timed mode" : "Unlimited mode";
      syncConfigFromUI();
      resetAll();
    }
    modeTimedBtn.addEventListener("click", () => setMode("timed"));
    modeUnlimitedBtn.addEventListener("click", () => setMode("unlimited"));

    // ---------- Config ----------
    function syncConfigFromUI(){
      durationSec = parseInt(durationSelect.value, 10);
      rollingWindowSec = parseInt((mode === "timed" ? rollingSelectTimed.value : rollingSelectUnlimited.value), 10);
      historySec = historySelect ? parseInt(historySelect.value, 10) : 60;
      rollSubEl.textContent = `Last ${rollingWindowSec}s`;
    }
    durationSelect.addEventListener("change", syncConfigFromUI);
    rollingSelectTimed.addEventListener("change", syncConfigFromUI);
    rollingSelectUnlimited.addEventListener("change", syncConfigFromUI);
    if (historySelect){
      historySelect.addEventListener("change", () => { syncConfigFromUI(); drawChart(); });
    }

    // ---------- Run control ----------
    function beginCooldown(now){
      if (mode !== "timed") return;
      cooldownStartedAt = now;
      cooldownUntil = now + COOLDOWN_MS;
      runStateEl.textContent = "Cooldown";
      runStateEl.style.color = "var(--warn)";
    }

    function clearCooldown(){
      cooldownUntil = 0;
      cooldownStartedAt = 0;
    }

    function canStart(now){
      return now >= cooldownUntil;
    }

    function start(){
      if (running) return;
      const now = performance.now();
      if (!canStart(now)) return;

      syncConfigFromUI();

      running = true;
      startWall = now;
      stopWall = 0;
      endWall = (mode === "timed") ? (startWall + durationSec * 1000) : null;

      totalInputs = 0;
      lastInputLabel = "—";
      last1sQueue = [];
      buckets = [];
      lastBucketIndex = -1;
      peakCps = 0;

      clearCooldown();

      btnStart.disabled = true;
      btnStop.disabled = false;
      runStateEl.textContent = "Running";
      runStateEl.style.color = "var(--good)";
      drawChart();
    }

    function stop(){
      if (!running) return;
      running = false;
      stopWall = performance.now();

      btnStart.disabled = false;
      btnStop.disabled = true;

      if (mode === "timed"){
        beginCooldown(stopWall);
      } else {
        runStateEl.textContent = "Stopped";
        runStateEl.style.color = "var(--warn)";
      }
    }

    function finishTimed(){
      if (!running) return;
      running = false;
      stopWall = endWall ?? performance.now();

      btnStart.disabled = false;
      btnStop.disabled = true;

      // Cooldown so spam clicking doesn't instantly restart
      beginCooldown(stopWall);
    }

    function resetAll(){
      running = false;
      startWall = 0;
      stopWall = 0;
      endWall = null;

      totalInputs = 0;
      lastInputLabel = "—";
      last1sQueue = [];
      buckets = [];
      lastBucketIndex = -1;
      peakCps = 0;

      clearCooldown();

      btnStart.disabled = false;
      btnStop.disabled = true;
      runStateEl.textContent = "Idle";
      runStateEl.style.color = "var(--muted)";
      renderUI(performance.now());
      drawChart();
    }

    btnStart.addEventListener("click", start);
    btnStop.addEventListener("click", stop);
    btnReset.addEventListener("click", resetAll);

    // ---------- Input counting ----------
    function shouldCountPointer(e){
      if (e.pointerType === "mouse") return countMouse.checked;
      if (e.pointerType === "touch" || e.pointerType === "pen") return countTouch.checked;
      return false;
    }

    function pruneLast1s(now){
      const cutoff = now - 1000;
      while (last1sQueue.length && last1sQueue[0] < cutoff) last1sQueue.shift();
    }

    function registerInput(label){
      if (!running) return;

      const now = performance.now();

      // Timed end check: finish and ignore late input
      if (mode === "timed" && endWall !== null && now >= endWall){
        finishTimed();
        return;
      }

      totalInputs++;
      lastInputLabel = label;

      last1sQueue.push(now);

      const secIndex = Math.floor((now - startWall) / 1000);
      while (buckets.length <= secIndex) buckets.push(0);
      buckets[secIndex]++;

      pruneLast1s(now);
      if (last1sQueue.length > peakCps) peakCps = last1sQueue.length;
    }

    // Keyboard
    window.addEventListener("keydown", (e) => {
      if (!countKeyboard.checked) return;
      if (isUiControlTarget(e.target)) return;
      if (ignoreKeyRepeat.checked && e.repeat) return;

      if (preventScrollKeys.checked){
        const scrollKeys = [" ", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"];
        if (scrollKeys.includes(e.key)) e.preventDefault();
      }

      registerInput(`Key: ${e.key}`);
    }, { passive: false });

    // Global pointer handler (counts clicks anywhere that's not UI)
    window.addEventListener("pointerdown", (e) => {
      if (!shouldCountPointer(e)) return;
      if (isUiControlTarget(e.target)) return;

      // prevent context menu if right-click happens on pad
      if (e.pointerType === "mouse" && e.button === 2 && testPad && testPad.contains(e.target)){
        e.preventDefault();
      }

      const btnName = (e.pointerType === "mouse")
        ? ["LMB","MMB","RMB","X1","X2"][e.button] ?? `Btn${e.button}`
        : (e.pointerType === "touch" ? "Touch" : "Pen");

      registerInput(`${e.pointerType}: ${btnName}`);
    });

    // Wheel
    window.addEventListener("wheel", () => {
      if (!running) return;
      if (!countWheel.checked) return;
      if (isUiControlTarget(document.activeElement)) return;
      registerInput("Wheel");
    }, { passive: true });

    // Disable context menu ONLY on the Test Pad
    if (testPad){
      testPad.addEventListener("contextmenu", (e) => e.preventDefault());

      // Click-to-start behavior ONLY on the Test Pad
      // Use capture + stopPropagation so the same click doesn't get handled twice.
      testPad.addEventListener("pointerdown", (e) => {
        if (isUiControlTarget(e.target)) return;

        // Right click on pad: suppress menu
        if (e.pointerType === "mouse" && e.button === 2) e.preventDefault();

        // If idle/stopped/finished, start when pad clicked (but respect cooldown)
        if (!running){
          const now = performance.now();
          if (canStart(now)){
            start();
          }
          // Don't let this click bubble and accidentally do anything else
          e.stopPropagation();
        }
      }, { capture: true });
    }

    // Focus indicator
    function updateFocusUI(){
      const focused = document.hasFocus() && document.visibilityState === "visible";
      focusDot.classList.toggle("good", focused);
      focusText.textContent = focused ? "Focused" : "Not focused";
    }
    window.addEventListener("focus", updateFocusUI);
    window.addEventListener("blur", updateFocusUI);
    document.addEventListener("visibilitychange", updateFocusUI);
    window.addEventListener("pointerdown", updateFocusUI);
    updateFocusUI();

    // ---------- Gamepad polling ----------
    function updateGamepads(){
      const gps = navigator.getGamepads ? navigator.getGamepads() : [];
      const connected = [];

      for (const gp of gps){
        if (!gp) continue;
        connected.push(`${gp.index}: ${gp.id}`);

        if (!countGamepad.checked) continue;

        const prev = gpPrev.get(gp.index) || new Array(gp.buttons.length).fill(false);
        for (let i = 0; i < gp.buttons.length; i++){
          const pressed = !!gp.buttons[i]?.pressed;
          if (pressed && !prev[i]){
            registerInput(`Gamepad${gp.index}: B${i}`);
          }
          prev[i] = pressed;
        }
        gpPrev.set(gp.index, prev);
      }

      gpListEl.textContent = connected.length ? connected.join(" | ") : "None";
    }
    window.addEventListener("gamepadconnected", updateGamepads);
    window.addEventListener("gamepaddisconnected", (e) => {
      gpPrev.delete(e.gamepad.index);
      updateGamepads();
    });

    // ---------- UI render loop ----------
    function getElapsed(now){
      if (!startWall) return 0;
      const end = running ? now : (stopWall || now);
      return Math.max(0, (end - startWall) / 1000);
    }

    function getRemaining(now){
      if (mode !== "timed" || endWall === null) return Infinity;
      return Math.max(0, (endWall - now) / 1000);
    }

    function getCurrentCps(now){
      pruneLast1s(now);
      return last1sQueue.length;
    }

    function getRollingAvgCps(now){
      if (!startWall) return 0;
      const elapsed = getElapsed(now);
      const curSec = Math.floor(elapsed);
      const startSec = Math.max(0, curSec - (rollingWindowSec - 1));

      let sum = 0;
      for (let s = startSec; s <= curSec; s++){
        sum += buckets[s] || 0;
      }
      const secsCounted = (curSec - startSec + 1);
      return secsCounted > 0 ? (sum / secsCounted) : 0;
    }

    function updatePadUi(now){
      // Cooldown visuals (timed mode only)
      const inCooldown = (mode === "timed") && (now < cooldownUntil);

      if (inCooldown){
        const remainingMs = Math.max(0, cooldownUntil - now);
        const remain = (remainingMs / 1000).toFixed(2);
        padBadge.textContent = `Cooldown: ${remain}s`;
        cooldownBarWrap.style.display = "block";
        const prog = 1 - (remainingMs / COOLDOWN_MS);
        cooldownBar.style.width = `${Math.max(0, Math.min(1, prog)) * 100}%`;
        padSub.textContent = "Cooldown prevents accidental restart while you’re still clicking.";
        return;
      } else {
        cooldownBarWrap.style.display = "none";
        cooldownBar.style.width = "0%";
      }

      if (running){
        if (mode === "timed"){
          const rem = getRemaining(now);
          padBadge.textContent = `Running • ${formatSeconds(rem)} left`;
        } else {
          padBadge.textContent = "Running";
        }
        padSub.textContent = "Clicking counts now. Right-click menu is disabled on the pad.";
      } else {
        // Not running
        if (mode === "timed"){
          padBadge.textContent = `Click to start (${durationSec}s)`;
        } else {
          padBadge.textContent = "Click to start (Unlimited)";
        }
        padSub.textContent = "Left / middle / right click count • right-click menu disabled • keyboard works when page is focused";
      }

      // If cooldown ended and we were showing "Cooldown" state, switch runState label
      if (mode === "timed" && runStateEl.textContent === "Cooldown"){
        runStateEl.textContent = "Finished";
        runStateEl.style.color = "var(--warn)";
      }
    }

    function renderUI(now){
      syncConfigFromUI();

      if (running){
        const remaining = getRemaining(now);

        timeMain.textContent = formatSeconds(getElapsed(now));
        timeSub.textContent = (mode === "timed")
          ? `Remaining: ${formatSeconds(remaining)}`
          : "Unlimited";

        if (mode === "timed" && remaining <= 0){
          finishTimed();
        }
      } else {
        timeMain.textContent = formatSeconds(getElapsed(now));
        timeSub.textContent = (mode === "timed")
          ? `Interval: ${durationSec}s`
          : "Unlimited";
      }

      totalInputsEl.textContent = String(totalInputs);
      lastInputEl.textContent = `Last: ${lastInputLabel}`;

      const elapsedForAvg = Math.max(0.001, getElapsed(now));
      avgCpsEl.textContent = (totalInputs / elapsedForAvg).toFixed(2);

      curCpsEl.textContent = String(running ? getCurrentCps(now) : 0);
      peakCpsEl.textContent = String(peakCps);
      rollCpsEl.textContent = (running ? getRollingAvgCps(now) : 0).toFixed(2);

      updatePadUi(now);
      drawChart();
    }

    // ---------- Chart ----------
    function drawChart(){
      const showSecs = (mode === "timed") ? durationSec : historySec;

      let series = [];
      if (startWall){
        const elapsed = getElapsed(performance.now());
        const curSec = Math.floor(elapsed);
        const startSec = Math.max(0, curSec - (showSecs - 1));
        for (let s = startSec; s <= curSec; s++){
          series.push(buckets[s] || 0);
        }
      } else {
        series = new Array(Math.min(showSecs, 10)).fill(0);
      }

      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      const gridY = 4;
      for (let i = 1; i <= gridY; i++){
        const y = (h / (gridY + 1)) * i;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }

      const maxVal = Math.max(5, ...series);
      const padX = 16, padY = 16;
      const innerW = w - padX*2;
      const innerH = h - padY*2;

      const n = series.length;
      const gap = 2;
      const barW = n > 0 ? Math.max(1, Math.floor((innerW - (n-1)*gap) / n)) : innerW;

      for (let i = 0; i < n; i++){
        const v = series[i];
        const bh = Math.round((v / maxVal) * innerH);
        const x = padX + i*(barW + gap);
        const y = padY + (innerH - bh);

        ctx.fillStyle = "rgba(96,165,250,0.55)";
        ctx.fillRect(x, y, barW, bh);
      }

      ctx.fillStyle = "rgba(230,237,247,0.85)";
      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.fillText(`Max: ${maxVal} cps`, 14, 18);

      const rightLabel = (mode === "timed") ? `${durationSec}s window` : `${historySec}s window`;
      const labelW = ctx.measureText(rightLabel).width;
      ctx.fillText(rightLabel, w - labelW - 14, 18);
    }

    // ---------- Animation loop ----------
    function loop(){
      const now = performance.now();

      updateGamepads();

      if (running){
        const secIndex = Math.floor((now - startWall) / 1000);
        if (secIndex !== lastBucketIndex){
          while (buckets.length <= secIndex) buckets.push(0);
          lastBucketIndex = secIndex;
        }
      }

      renderUI(now);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // init
    resetAll();
  </script>
</body>
</html>
